{
  "name": "binary-format",
  "version": "0.0.1",
  "description": "Two-way custom binary seralization",
  "main": "src/jprinter.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "mocha ntest/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/RobertBorg/node-BinaryFormat.git"
  },
  "keywords": [
    "binary",
    "struct",
    "parse",
    "seralization",
    "deseralization"
  ],
  "author": {
    "name": "Robert Borg"
  },
  "license": "",
  "readmeFilename": "README.md",
  "gitHead": "cb9ff1c3f31cbdebb8e8a5be3f3be13dbda0b0c4",
  "dependencies": {
    "jDataView": "git://github.com/vjeux/jDataView.git"
  },
  "devDependencies": {
    "mocha": "",
    "should": ""
  },
  "readme": "<a href=\"http://blog.vjeux.com/2011/javascript/binaryparser-unleash-javascript-power.html\">jParser</a> - Parsing binary files made easy.\n================================\n\njParser makes it easy to parse binary files in Javascript.\n\n * You write the structure once, it gets parsed automatically.\n * The parsing process can be extended with custom functions. It allows to parse non trivial files with ease.\n * It works both in the browser and NodeJS as it is powered by [jDataView](https://github.com/vjeux/jDataView).\n\nAPI\n======\n\nPrimitive Structures:\n\n  * **Unsigned Int**: uint8, uint16, uint32\n  * **Signed Int**: int8, int16, int32\n  * **Float**: float32, float64\n  * **String**: char, string(len)\n  * **Array**: array(type, len)\n  * **BitField**: (bitCount)\n  * **Position**: tell, skip(len), seek(pos), seek(pos, func)\n  * **Conditionals**: if(predicate, type)\n\njParser Methods:\n\n  * **parse(value)**: Run the parsing, can be used recursively.\n    * **Number**: Reads bitfield of given length in left-to-right mode and returns them as unsigned integer\n      (so you can work with them using simple JavaScript binary operators).\n      Please note that you can mix bitfields with primitive and complex types in one structure or even use\n      them in own functions, but **ALWAYS** make sure that consecutive bitfields are padded to integer\n      byte count (or **8*N bit count**) before reading any other data types; most popular data formats\n      already follow this rule but better to check out when writing own structures if you don't want\n      to get unexpected behavior.\n    * **Function**: Calls the function.\n    * **String**: Dereferences the value in the structure.\n    * **Array**: Function call, the function is the first element and arguments are the following.\n    * **Object**: Returns an object with the same keys and parses the values.\n  * **tell()**: Return the current position.\n  * **skip(count)**: Advance in the file by ``count`` bytes.\n  * **seek(position)**: Go to ``position``.\n  * **seek(position, callback)**: Go to ``position``, execute the ``callback`` and return to the previous position.\n  * **current**: The current object being parsed. See it as a way to use what has been parsed just before.\n\njParser Constructor:\n\n  * **new jParser(data, structure)**\n    * ``data`` is a [jDataView](https://github.com/vjeux/jDataView). You can give pretty much anything (String, [ArrayBuffer](https://developer.mozilla.org/en/JavaScript_typed_arrays), [Node Buffer](http://nodejs.org/docs/v0.6.2/api/buffers.html)), it will be casted to jDataView automatically.\n    * ``structure`` is an object with all the defined structures.\n\nExamples\n========\n\n**Basic C Structure**\nYou have the ability to define C-like structures. It's a Javascript object where keys are labels and values are types.\n\n```javascript\nvar parser = new jParser(file, {\n  header: {\n    fileId: 'int32',\n    recordIndex: 'int32',\n    hash: ['array', 'uint32', 4],\n    fileName: ['string', 256],\n    version: 2,\n    flags: {\n      precisionFlag: 1,\n      marker: {\n       part1: 2,\n       part2: 2\n      }\n    },\n    _reserved: 1 // padding to 8*N bits\n  }\n});\nparser.parse('header');\n// {\n//   fileId: 42,\n//   recordIndex: 6002,\n//   hash: [4237894687, 3491173757, 3626834111, 2631772842],\n//   fileName: \".\\\\Resources\\\\Excel\\\\Items_Weapons.xls\",\n//   version: 3,\n//   flags: {\n//     precisionFlag: 1,\n//     marker: {\n//       part1: 2,\n//       part2: 0\n//     }\n//   },\n//   _reserved: 0\n// }\n```\n\n**References**\nStructures can reference other structures. Use structure name within a string in order to reference it. The following is an example from World of Warcraft model files.\n\n```javascript\nnofs: {\n  count: 'uint32',\n  offset: 'uint32'\n},\n \nanimationBlock: {\n  interpolationType: 'uint16',\n  globalSequenceID: 'int16',\n  timestamps: 'nofs',\n  keyFrame: 'nofs'\n},\n \nuvAnimation: {\n  translation: 'animationBlock',\n  rotation: 'animationBlock',\n  scaling: 'animationBlock'\n}\n```\n\n**Helpers**\nIt is really easy to make new primitive types. You can either use existing constructions such as objects (```float3```) or arrays (```float4```). In case you want to do something more complicated, you always have the option to define a new function and use ```this.parse``` to keep parsing (```hex32```, ```string0```).\n\n```javascript\nfloat3: {\n  x: 'float32',\n  y: 'float32',\n  z: 'float32'\n},\nfloat4: ['array', 'float32', 4],\nhex32: function () {\n  return '0x' + this.parse('uint32').toString(16);\n},\nstring0: function (length) {\n  return this.parse(['string', length]).replace(/\\0+$/g, '');\n}\n```\n\n**Back Reference** Instead of using an integer for the array size, you can put a function that will return an integer. In this function, you can use ```this.current``` to reference the englobing object being parsed.\n\n```javascript\nimage: {\n  width: 'uint8',\n  height: 'uint8',\n  pixels: [\n    'array',\n    ['array', 'rgba', function () { return this.current.width; }],\n    function () { return this.current.height; }\n  ]\n}\n```\n\n**Advanced Parsing** The best part of jParser is that complicated parsing logic can be expressed within the structure. It allows to parse complex files without having to split structure from parsing code.\n\n```javascript\nentryHeader: {\n  start: 'int32',\n  count: 'int32'\n},\n\nentry: function (type) {\n  var that = this;\n  var header = this.parse('entryHeader');\n\n  var res = [];\n  this.seek(header.start, function () {\n    for (var i = 0; i < header.count; ++i) {\n      res.push(that.parse(type));\n    }\n  });\n  return res;\n},\n\nname: {\n language: 'int32',\n text: ['string', 256]\n},\n\nfile: {\n  names: ['entry', 'name']\n}\n```\n\n\nGet Started\n=======\n\n**NodeJS**: Just use ```npm``` to install ```jParser``` and you are set :)\n\n```bash\nnpm install jParser\n```\n\n```javascript\nvar fs = require('fs');\nvar jParser = require('jParser');\n\nfs.readFile('file.bin', function (err, data) {\n  var parser = new jParser(data, {\n    magic: ['array', 'uint8', 4]\n  });\n  console.log(parser.parse('magic'));\n});\n```\n\n**Browser**: I've [patched jQuery](https://github.com/vjeux/jDataView/blob/master/jquery/jquery-patch.txt) to allow to download binary files using the best binary format. You include this patched jQuery, jDataView and jParser and you are set :)\n\n```html\n<script src=\"https://raw.github.com/vjeux/jDataView/master/jquery/jquery-1.7.1-binary-ajax.js\"></script>\n<script src=\"https://raw.github.com/vjeux/jDataView/master/src/jdataview.js\"></script>\n<script src=\"https://raw.github.com/vjeux/jParser/master/src/jparser.js\"></script>\n\n<script>\n$.get('file.bin', function (data) {\n  var parser = new jParser(data, {\n    magic: ['array', 'uint8', 4]\n  });\n  console.log(parser.parse('magic'));\n}, 'dataview');\n</script>\n```\n\nCaveats\n=======\n\nThis tool works thanks to a feature that is not in the Javascript specification: When you iterate over an object keys, the keys will be listed in their order of insertion. Note that Chrome and Opera do not respect this implicit rule for keys that are numbers.\n\nIf you follow those two rules, the library will work in all the current Javascript implementations.\n\n * Do not start a key name with a digit\n * Do not put the same key twice in the same object\n\n\nDemos\n=====\n\n**ICO Parser**. This is a basic example to parse a binary file in NodeJS. It shows how to solve many common issues with binary file parsing.\n\n * **[ico.js](https://github.com/vjeux/jParser/blob/master/sample/ico/ico.node.js)**: jParser structure.\n * [ico.json](http://fooo.fr/~vjeux/github/jParser/sample/ico/favicon.json): parsed file.\n\n**[Tar Extractor](http://fooo.fr/~vjeux/github/jParser/sample/tar/tar.html)**. This is a basic example to parse a binary file in the browser.\n\n * **[tar.html](https://github.com/vjeux/jParser/blob/master/sample/tar/tar.html)**: jParser structure.\n\n**<a href=\"http://fooo.fr/~vjeux/github/jsWoWModelViewer/modelviewer.html\">World of Warcraft Model Viewer</a>.** It uses jParser to read the binary model and then WebGL to display it.\n\n  * **[m2.js](http://fooo.fr/~vjeux/github/jsWoWModelViewer/scripts/m2.js)**: jParser structure.\n  * [model.json](http://fooo.fr/~vjeux/github/jsWoWModelViewer/model.json): parsed file.\n\n<a href=\"http://fooo.fr/~vjeux/github/jsWoWModelViewer/modelviewer.html\"><img src=\"http://fooo.fr/~vjeux/github/jsWoWModelViewer/images/modelviewer.png\"></a>\n\n**Diablo 3 Internal Files**.\n\n  * **[convert.coffee](http://fooo.fr/~vjeux/boub/d3/files/convert.coffee)**: jParser structure. CoffeeScript makes it even easier to write file structure.\n  * Example of parsed files:\n    * [Items_Weapons.json](http://fooo.fr/~vjeux/boub/d3/files/GameBalance/Items_Weapons.json)\n    * [Quest/ProtectorOfTristam.json](http://fooo.fr/~vjeux/boub/d3/files/Quest/ProtectorOfTristram.json)\n    * [TreasureClass/SkeletonKing](http://fooo.fr/~vjeux/boub/d3/files/TreasureClass/SkeletonKing.json)\n",
  "bugs": {
    "url": "https://github.com/RobertBorg/node-BinaryFormat/issues"
  },
  "homepage": "https://github.com/RobertBorg/node-BinaryFormat",
  "_id": "binary-format@0.0.1",
  "_shasum": "e113cb5f543d0c4c32e79ca539fbcaa04eef98c5",
  "_from": "binary-format@",
  "_resolved": "https://registry.npmjs.org/binary-format/-/binary-format-0.0.1.tgz"
}
